{
    "collab_server" : "",
    "contents" : "#' Bayesian Information Criterion for PPCA.\n#'\n#' The function returns the dimension that minimized the BIC based on the\n#'    profile log-likelihood while considering all possible dimensions.\n#'\n#' @param lambda a numeric vector of positive sample eigenvalues that sums to N\n#' @param M a positive integer for the number of observations or features``\n#' @return an integer K between 1 and N that minimizes the BIC.\n#'\n#' @examples\n#' \\dontrun{\n#' library(MASS)\n#' X <- mvrnorm(5000, mu = rep(0,10), Sigma = diag(1,10))\n#' eigen_values <- eigen(as.matrix(Matrix::nearPD(stats::cov(scale((X))))$mat))$val\n#' BIC(lambda = eigen_values, M = 1000)\n#' BIC(lambda = eigen_values, M = 5000)\n#' }\n#' @keywords information criterion, profile log-likelihood, model selection,\n#'\n#' @references Schwarz, Gideon E. (1978), Estimating the dimension of a model,\n#'    \\emph{Annals of Statistics}, \\strong{6} (2): 461–464, MR 468014,\n#'    doi:10.1214/aos/1176344136\n#'\n\nBIC <- function(lambda, M) {\n\n    lambda <- as.numeric(lambda)\n    N <- sum(lambda > 0, na.rm = T)\n    lambda <- ifelse(lambda > 0, lambda, 0)\n    which.min(-2 * ppcaLog(lambda=lambda, M=M) + (((1:(N -\n        1)) * N + 1 - (1:(N - 1)) * ((1:(N - 1)) - 1)/2) * log(M)))\n}\n\n#----------------------------------------------------------------------------------\n\n#' Akaike Information Criterion for PPCA.\n#'\n#' The function returns the dimension that minimized the AIC based on the\n#'    profile log-likelihood while considering all possible dimensions.\n#'\n#' @param lambda a numeric vector of positive sample eigenvalues that sums to N\n#' @param M a positive integer for the number of observations or features``\n#' @return an integer K between 1 and N that minimizes the AIC.\n#'\n#' @examples\n#' \\dontrun{\n#' library(MASS)\n#' X <- mvrnorm(1000, mu = rep(0,10), Sigma = diag(1,10))\n#' eigen_values <- eigen(as.matrix(Matrix::nearPD(stats::cov(scale((X))))$mat))$val\n#' AIC(lambda = eigen_values, M = 1000)\n#' AIC(lambda = eigen_values, M = 5000)\n#' }\n#'\n#' @keywords information criterion, profile log-likelihood, model selection\n#'\n#' @references Akaike, H. (1974), A new look at the statistical model identification,\n#'    \\emph{IEEE Transactions on Automatic Control}, \\strong{19} (6): 716–723, MR 0423716,\n#'    doi:10.1109/TAC.1974.1100705.\n#'\n\nAIC <- function(lambda, M) {\n\n    lambda <- as.numeric(lambda)\n    N <- sum(lambda > 0, na.rm = T)\n    lambda <- ifelse(lambda > 0, lambda, 0)\n    which.min((-2 * ppcaLog(lambda=lambda, M=M) + (((1:(N -\n        1)) * N + 1 - (1:(N - 1)) * ((1:(N - 1)) - 1)/2)) * 2))\n}\n\n#----------------------------------------------------------------------------------\n\n\n#' Alternative methods based on the detection of elbow in sample eigenvalues.\n#'\n#' The function returns the dimension that is selected based on various methods that\n#'    attempt to detect an ``elbow'' in sample eigenvalues.\n#'\n#' @param lambda a numeric vector of positive sample eigenvalues that sums to $N$.\n#' @param methods a character vector of possible methods to detect an elbow in sample eigenvalues.\n#' @return an integer $K$ between 1 and $N$.\n#'\n#' @examples\n#' \\dontrun{\n#' library(MASS)\n#' X <- mvrnorm(1000, mu = rep(0,10), Sigma = diag(1,10))\n#' eigen_values <- eigen(as.matrix(Matrix::nearPD(stats::cov(scale(X)))$mat))$val\n#' elbowEigen(lambda = eigen_values)\n#' elbowEigen(lambda = eigen_values)\n#' }\n#'\n#' @author Wei Q. Deng, \\email{deng@@utstat.toronto.edu}\n#'\n#' @keywords sample eigenvalues, elbow approach\n\nelbowEigen <- function(lambda,\n                       methods = c(\"adjD\", \"cumD\", \"varD\", \"cumlog\", \"logsigma2\")){\n\n  all_methods <- c(\"adjD\", \"cumD\", \"varD\", \"cumlog\", \"logsigma2\")\n\n  lambda <- as.numeric(lambda)\n  N <- sum(lambda > 0, na.rm = T)\n\n  adjD <- which.min(c(lambda[-1]/lambda[-N], 1))\n  cumD <- which.max(cumsum(lambda)/(1:N)/((sum(lambda) - cumsum(lambda))/(N - 0:(N - 1))))\n\n  varD <- which.max(sapply(1:N, function(x) stats::var(lambda[1:x])))\n  cumlog <- which.min(log(cumsum(lambda))/(1:N - cumsum(log(lambda))))\n  logsigma2 <- which.min(log((N - cumsum(lambda)[-N])/(N - 1:(N - 1)) * (N - 1:(N - 1))))\n\n  output <- data.frame(adjD, cumD, varD, cumlog, logsigma2)\n  names(output) <- all_methods\n  return(output[,all_methods %in% methods])\n}\n\n\n#' Likelihood Ratio Tests for equality of last $n-K$ eigenvalues.\n#'\n#' The function returns the dimension that minimizes the $p$-value from the\n#'   likelihood ratio test (LRT) derived by Lawley (1956).\n#'\n#'\n#' @param lambda a numeric vector of positive sample eigenvalues that sums to $N$\n#' @param M a positive integer for the number of observations or features``\n#' @return an integer $K$ between 1 and $N$ that minimizes the LRT $p$-value.\n#'\n#' @examples\n#' \\dontrun{\n#' library(MASS)\n#' X <- mvrnorm(1000, mu = rep(0,10), Sigma = diag(1,10))\n#' eigen_values <- eigen(as.matrix(Matrix::nearPD(stats::cov(scale(t(X))))$mat))$val\n#' Lawley.Test(lambda = eigen_values, M = 1000)\n#' }\n#'\n#' @author Wei Q. Deng, \\email{deng@@utstat.toronto.edu}\n#'\n#' @references Lawley, D. N. (1956) Tests of significance for the latent roots of\n#'    stats::covariance and correlation matrices. \\emph{Biometrika} \\strong{43}.1/2: 128-136.\n#'\n#' @keywords hypothesis testing, likelihood ratio test,\n#'\n\nLawley.Test <- function(lambda, M) {\n\n  lambda <- as.numeric(lambda)\n  N <- sum(lambda > 0, na.rm = T)\n  f = M - 1\n  pvalue <- sapply(1:N, function(x) {\n    p <- N - x\n    logQ = sum(log(lambda[x:N])) - p*log(sum(lambda[x:N]/p))\n    constant <- -(f - x - 1/6 * (2*p + 1 + 2/p))\n    teststat <- constant * logQ\n    stats::pchisq(teststat, p * (p + 1)/2 - 1, lower.tail = F)\n  })\n  which.min(pvalue)\n  }\n\n\n#----------------------------------------------------------------------------------\n\n#' Cross-validation for the PPCA model.\n#'\n#' The function returns the profile log-likelihood\n#'    of the PPCA model at respective MLEs for a specific\n#'    choice of $K=k$ evaluated by cross-validation.\n#'\n#' @param x a data matrix with the number of rows to be reduced; only complete columns are used.\n#' @param k an integer indicating the tested dimension, should be between 1 and the number of rows of \\code{x}.\n#' @param fold an integer indicating the number of folds to be used.\n#' @return profile log-likelihood of the remaining fold evaluated at MLEs computed from other folds.\n#'\n#' @importFrom MASS mvrnorm\n#' @importFrom Matrix nearPD\n#' @importFrom mvtnorm dmvnorm\n#' @importFrom psych tr\n#'\n#' @examples\n#' \\dontrun{\n#' library(MASS)\n#' X <- mvrnorm(1000, mu = rep(0,50), Sigma = diag(1,50))\n#' ppcaCV(k = 5, x = X, fold = 5) # 5-fold cross-validation.\n#' }\n#'\n#' @author Wei Q. Deng, \\email{deng@@utstat.toronto.edu}\n#'\n#' @references Tipping, M. E., and Bishop, C. M. (1999). Probabilistic principal component analysis.\n#'    \\emph{Journal of the Royal Statistical Society: Series B (Statistical Methodology)},\n#'    \\strong{61}(3), 611-622.\n#'\n#' @keywords probabilistic PCA, cross validation, profile log-likelihood, model selection\n#'\n\nppcaCV <- function(k = NULL, x = NULL, fold = 5) {\n\n\nif (is.null(x)) {\n  stop(\"Please provide a data matrix\")\n}\n\nif (is.null(k) | is.na(k)) {\n  stop(\"Please specify the dimension to be tested in cross-validation\")\n}\n\n  X <- as.matrix(x[!apply(x, 2, function(xx) sum(is.na(xx)) > 0),])\n  k <- as.integer(k)\n\n  if (k > nrow(X) | k < 1) {\n    stop(\"Please ensure k is an integer between 1 and the number of rows of the data matrix x\")\n  }\n\n  block_size <- floor(dim(X)[1]/fold)\n  logf <- NA\n  for (i in 1:fold) {\n    test <- X[c(1:block_size + (i - 1) * block_size),]\n    train <- X[-c(1:block_size + (i - 1) * block_size),]\n    list_ppca <- ppcaMLE(t(train), nComp = k)\n    WTrain <- list_ppca$W\n    sigma2Train <- list_ppca$sigma2\n    logf[i] <- ppcaLog(t(test), param = list(WTrain, sigma2Train), EM = FALSE)\n    print(paste(\"it is the \", i, \"th fold,\", \"testing nComp = \", k, \". Please be patient...\"))\n  }\n  return(logf)\n}\n",
    "created" : 1521437353696.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "833645314",
    "id" : "DA1534EB",
    "lastKnownWriteTime" : 1521437368,
    "last_content_update" : 1521437368874,
    "path" : "~/Documents/AcademicResearch/kraken_files/WeiGit/SPAC2/R/alternative.R",
    "project_path" : "R/alternative.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}